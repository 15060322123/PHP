PHP 变量在内核中的实现
===

所有的编程语言都要提供一种数据的存储与检索机制，PHP 也不例外。其它语言大都需要在使用变量之前先定义，并且它的类型也是无法再次改变的，而 PHP 却允许自由的使用变量而无须提前定义，甚至可以随时随意的对已存在的变量转换成其它任何 PHP 支持的数据类型。当程序在运行的时候，PHP还会自动的根据需求转换变量的类型。

变量的类型
---

+ PHP在内核中是通过 zval 这个结构体来存储变量的，它的定义在 Zend/zend.h 文件里，由四个成员组成：
```c
struct _zval_struct {
    zvalue_value value; /* 变量的值 */
    zend_uint refcount__gc;
    zend_uchar type;    /* 变量当前的数据类型 */
    zend_uchar is_ref__gc;
};
typedef struct _zval_struct zval;
```

+ 保存变量值的 value 是 zvalue_value 类型(PHP5)，它是一个 union，同样定义在了 Zend/zend.h 文件里：
```c
typedef union _zvalue_value {
    long lval;          /* long value */
    double dval;        /* double value */
    struct {
        char *val;
        int len;
    } str;
    HashTable *ht;      /* hash table value */
    zend_object_value obj;
} zvalue_value;
```

+ PHP 的八种数据类型
  + IS_NULL
  + IS_BOOL
  + IS_LONG
  + IS_DOUBLE
  + IS_STRING
  + IS_ARRAY
  + IS_OBJECT
  + IS_RESOURCE

+ 检查变量类型的宏函数
```c
#define Z_TYPE(zval)        (zval).type
#define Z_TYPE_P(zval_p)    Z_TYPE(*zval_p)
#define Z_TYPE_PP(zval_pp)  Z_TYPE(**zval_pp)
```

变量的值
---

+ PHP内核提供了三个基础宏来方便对变量的值进行操作，这几个宏同样以Z_开头，并且P结尾和PP结尾的同上一节中的宏一样， 分别代表这参数是指针还是指针的指针。
  + 针对 IS_LONG 类型的 LAVL 组合 (Z_LVAL、Z_LAVL_P、Z_LAVL_PP)
  + 针对 IS_BOOL 类型的 BVAL 组合 (Z_BVAL、Z_BVAL_P、Z_BVAL_PP)
  + 针对 IS_DOUBLE 类型的 DVAL 组合 (Z_DVAL、Z_DVAL_P、Z_DVAL_PP)
  + 针对 IS_STRING 类型的 STRVAL 组合 (Z_STRVAL、Z_STRVAL_P、Z_STRVAL_PP)
  + 针对 IS_STRING 类型的 STRLEN 组合 (Z_STRLEN、Z_STRLEN_P、Z_STRLEN_PP)
  + 针对 IS_ARRAY 类型的 ARRVAL 组合 (Z_ARRVAL、Z_ARRVAL_P、Z_ARRVAL_PP)
  + IS_OBJECT 类型是一个复杂的结构体 (zend_object_value)
    + OBJ_HANDLE 返回 handle 标识符
    + OBJ_HT handle 表
    + OBJCE 定义类
    + OBJPROP HashTable 的属性
    + OBJ_HANDLER 在 OBJ_HT 中操作一个特殊的handler方法
  + IS_RESOURCE 类型是一个整数，使用 RESVAL 组合 (Z_RESVAL、Z_RESVAL_P、Z_RESVAL_PP) 

+ 有关值操作的宏都定义在 ./Zend/zend_operators.h 文件里：
```c
//操作整数的
#define Z_LVAL(zval)            (zval).value.lval
#define Z_LVAL_P(zval_p)        Z_LVAL(*zval_p)
#define Z_LVAL_PP(zval_pp)      Z_LVAL(**zval_pp)

//操作IS_BOOL布尔型的
#define Z_BVAL(zval)            ((zend_bool)(zval).value.lval)
#define Z_BVAL_P(zval_p)        Z_BVAL(*zval_p)
#define Z_BVAL_PP(zval_pp)      Z_BVAL(**zval_pp)

//操作浮点数的
#define Z_DVAL(zval)            (zval).value.dval
#define Z_DVAL_P(zval_p)        Z_DVAL(*zval_p)
#define Z_DVAL_PP(zval_pp)      Z_DVAL(**zval_pp)

//操作字符串的值和长度的
#define Z_STRVAL(zval)          (zval).value.str.val
#define Z_STRVAL_P(zval_p)      Z_STRVAL(*zval_p)
#define Z_STRVAL_PP(zval_pp)    Z_STRVAL(**zval_pp)

#define Z_STRLEN(zval)          (zval).value.str.len
#define Z_STRLEN_P(zval_p)      Z_STRLEN(*zval_p)
#define Z_STRLEN_PP(zval_pp)    Z_STRLEN(**zval_pp)

#define Z_ARRVAL(zval)          (zval).value.ht
#define Z_ARRVAL_P(zval_p)      Z_ARRVAL(*zval_p)
#define Z_ARRVAL_PP(zval_pp)    Z_ARRVAL(**zval_pp)

//操作对象的
#define Z_OBJVAL(zval)          (zval).value.obj
#define Z_OBJVAL_P(zval_p)      Z_OBJVAL(*zval_p)
#define Z_OBJVAL_PP(zval_pp)    Z_OBJVAL(**zval_pp)

#define Z_OBJ_HANDLE(zval)      Z_OBJVAL(zval).handle
#define Z_OBJ_HANDLE_P(zval_p)  Z_OBJ_HANDLE(*zval_p)
#define Z_OBJ_HANDLE_PP(zval_p) Z_OBJ_HANDLE(**zval_p)

#define Z_OBJ_HT(zval)          Z_OBJVAL(zval).handlers
#define Z_OBJ_HT_P(zval_p)      Z_OBJ_HT(*zval_p)
#define Z_OBJ_HT_PP(zval_p)     Z_OBJ_HT(**zval_p)

#define Z_OBJCE(zval)           zend_get_class_entry(&(zval) TSRMLS_CC)
#define Z_OBJCE_P(zval_p)       Z_OBJCE(*zval_p)
#define Z_OBJCE_PP(zval_pp)     Z_OBJCE(**zval_pp)

#define Z_OBJPROP(zval)         Z_OBJ_HT((zval))->get_properties(&(zval) TSRMLS_CC)
#define Z_OBJPROP_P(zval_p)     Z_OBJPROP(*zval_p)
#define Z_OBJPROP_PP(zval_pp)   Z_OBJPROP(**zval_pp)

#define Z_OBJ_HANDLER(zval, hf)     Z_OBJ_HT((zval))->hf
#define Z_OBJ_HANDLER_P(zval_p, h)  Z_OBJ_HANDLER(*zval_p, h)
#define Z_OBJ_HANDLER_PP(zval_p, h) Z_OBJ_HANDLER(**zval_p, h)

#define Z_OBJDEBUG(zval,is_tmp)         (Z_OBJ_HANDLER((zval),get_debug_info)?  \
                                        Z_OBJ_HANDLER((zval),get_debug_info)(&(zval),&is_tmp TSRMLS_CC): \
                                        (is_tmp=0,Z_OBJ_HANDLER((zval),get_properties)?Z_OBJPROP(zval):NULL)) 
#define Z_OBJDEBUG_P(zval_p,is_tmp)     Z_OBJDEBUG(*zval_p,is_tmp) 
#define Z_OBJDEBUG_PP(zval_pp,is_tmp)   Z_OBJDEBUG(**zval_pp,is_tmp)

//操作资源的
#define Z_RESVAL(zval)          (zval).value.lval
#define Z_RESVAL_P(zval_p)      Z_RESVAL(*zval_p)
#define Z_RESVAL_PP(zval_pp)    Z_RESVAL(**zval_pp)
```

创建 PHP 变量
---

+ MAKE_STD_ZVAL(pzv)
  > 这个宏会用内核的方式来申请一块内存并将其地址付给 pzv，并初始化它的 refcount__gc 和 is_ref__gc 两个属性，它不但会自动的处理内存不足问题，还会在内存中选个最优的位置来申请。

+ ALLOC_INIT_ZVAL(pzv)
  > 类似 MAKE_STD_ZVAL() 宏，唯一的不同便是它会将 pzv 所指的 zval 的类型设置为 IS_NULL。

+ 内核中提供一些宏来简化操作，可以只用一步便设置好 zval 的类型和值：
```c
ZVAL_NULL(pvz)                      /* 将 pzv 所指的 zavl 设置为 IS_NULL 类型 */
ZVAL_BOOL(pzv, b)                   /* 将 pzv 所指的 zval 设置为 IS_BOOL 类型，值是 b */
ZVAL_FALSE(pzv)                     /* 将 pzv 所指的 zval 设置为 IS_BOOL 类型，值是 false */
ZVAL_LONG(pzv, l)                   /* 将 pzv 所指的 zval 设置为 IS_LONG 类型，值是 l */
ZVAL_DOUBLE(pzv, d)                 /* 将 pzv 所指的 zval 设置为 IS_DOUBLE 类型，值是 d */
ZVAL_STRINGL(pzv,str,len,dup)       /* str 和len 两个参数分别对应内核中保存了字符串的地址和它的长度，dup 参数指明了该字符串是否需要被复制。值为 1 将先申请一块新内存并赋值该字符串，然后把新内存的地址复制给pzv，为 0 时则是直接把 str 的地址赋值给 zval */
ZVAL_STRING(pzv, str, dup)          /* 与 ZVAL_STRINGL 的区别：如果你想在某一位置截取该字符串或已经知道了这个字符串的长度，那么可以使用宏 ZVAL_STRINGL(zval, string, length, duplicate)，它显式的指定字符串长度，而不是使用 strlen()。这个宏用该字符串长度作为参数，它是二进制安全的，而且速度也比 ZVAL_STRING 快，因为少了个 strlen() */
ZVAL_RESOURCE(pzv, res)             /* 这个宏约等于 ZVAL_LONG，PHP 中的资源类型的值其实就是一个整数，所以 ZVAL_RESOURCE 和 ZVAL_LONG 的工作差不多， 只不过它会把 zval 的类型设置为 IS_RESOURCE */
```

links
---

+ [目录](00.目录.md)
+ 上一节: [PHP的生命周期](01.PHP的生命周期.md)
+ 下一节: [内存管理](03.内存管理.md)
