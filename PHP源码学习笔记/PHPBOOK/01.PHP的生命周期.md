PHP 的生命周期
===

让我们从 SAPI 开始
---

+ SPAI (Server Application Programming Interface)
  > SAPI 就是 PHP 和外部环境的代理器。它把外部环境抽象后, 为内部的 PHP 提供一套固定的, 统一的接口, 使得 PHP 自身实现能够不受错综复杂的外部环境影响，保持一定的独立性。相关链接：[深入理解 Zend SAPIs](http://www.laruence.com/2008/08/12/180.html)

+ CLI (Command-line Interface)

PHP 的启动与终止
---

+ PHP 程序的启动与终止可以看作两个概念
  + 作为 Apache 的一个模块启动与终止
  + 当 Apache 分配一个页面请求的时候，PHP会有一次启动与终止

+ MINIT (Module Initialization)
  > PHP_MINIT_FUNCTION() 宏函数，这里定义的常量、类、资源等都会随着 Apache 常驻内存。

+ RINIT (Request Initialization)
  > PHP_RINIT_FUNCTION() 宏函数，将初始化在本次请求中会使用到的变量与 PHP 脚本中的变量。

+ RSHUTDOWN (Request Shutdown)
  > PHP_RSHUTDOWN_FUNCTION() 宏函数，会释放掉这次请求使用过的所有东西，包括变量表的所有变量、所有在这次请求中申请的内存等。

+ MSHUTDOWN (Module Shutdown)
  > PHP_MSHUTDOWN_FUNCTION() 宏函数，当 Apache 要停止时，会执行所有扩展中的 MSHUTDOWN 方法。

PHP 的生命周期
---
+ PHP 通过 SAPI 与宿主通信的四种方式
  + 直接以CLI/CGI模式调用
  + 多进程模式
  + 多线程模式
  + Embedded(嵌入式，在自己的 C 程序中调用 Zend Engine)

+ CLI/CGI
  > 这时 PHP 的生命周期完全在一个单独的请求中完成。虽然简单，不过我们以前提过的两种 init 和两种 shutdown 仍然都会被执行。

+ 多进程模式
  > 当 Apache 启动的时候，会立即把自己fork出好几个子进程，每一个进程都有自己独立的内存空间，也就代表了有自己独立的变量、函数等。因为是fork出来的，所以各个进程间的数据是彼此独立，不会受到外界的干扰。

+ 多线程模式
  > 在这种模式下，只有一个服务器进程在运行着，但会同时运行很多线程，这样可以减少一些资源开销，像 Module init 和 Module shutdown 就只需要运行一次就行了，一些全局变量也只需要初始化一次， 因为线程独具的特质，使得各个请求之间方便的共享一些数据成为可能。

+ Embed
  > 它可能随时嵌入到某个程序里，然后被当作脚本的一部分在一个请求的时候执行，控制权在PHP和原程序间来回传递。相关链接：[使用PHP Embed SAPI实现Opcodes查看器](http://www.laruence.com/2008/09/23/539.html)


links
---

+ [目录](00.目录.md)
+ 上一节: 没有了
+ 下一节: [PHP变量在内核中的实现](02.PHP变量在内核中的实现.md)
